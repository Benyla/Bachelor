#!/usr/bin/env python3
"""
compute_fid.py

Compute Fr√©chet Inception Distance (FID) between real validation set samples and
samples generated by a trained VAE model, using the pytorch-fid library's InceptionV3
pool3 features for standard benchmarking.
"""
import argparse
import os
import torch
import torch.nn.functional as F
import numpy as np
from torch.utils.data import DataLoader, TensorDataset, Subset
from torchvision import transforms

import time
from tqdm import tqdm

from pytorch_fid.inception import InceptionV3
from pytorch_fid.fid_score import calculate_frechet_distance

from src.utils.config_loader import load_config
from src.utils.data_loader import get_data, SingleCellDataset
from src.models.VAE import VAE


def get_activations(data_loader, model, device):
    """
    Extract pooled InceptionV3 pool3 activations (2048-D) for all samples in data_loader.
    """
    model.eval()
    activations = []
    normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                     std=[0.229, 0.224, 0.225])

    with torch.no_grad():
        for batch in tqdm(data_loader, desc="Computing activations"):
            # unpack if needed
            if isinstance(batch, (list, tuple)):
                batch = batch[0]
            batch = batch.to(device)
            # convert to 3-channel if single-channel
            if batch.dim() == 4 and batch.shape[1] == 1:
                batch = batch.repeat(1, 3, 1, 1)
            # resize to 299x299
            batch = F.interpolate(batch, size=(299, 299), mode='bilinear', align_corners=False)
            # normalize
            batch = normalize(batch)
            # forward through Inception
            pred = model(batch)[0]  # list with one element: pool3
            # flatten spatial dims
            pred = pred.squeeze(3).squeeze(2)
            activations.append(pred.cpu().numpy())
    return np.concatenate(activations, axis=0)


def calculate_activation_statistics(activations):
    """
    Compute mean and covariance of activations.
    """
    mu = np.mean(activations, axis=0)
    sigma = np.cov(activations, rowvar=False)
    return mu, sigma


def generate_images(model, num_samples, latent_dim, device, batch_size):
    """
    Generate images by sampling from the VAE's latent space.
    """
    model.eval()
    images = []
    with torch.no_grad():
        for i in range(0, num_samples, batch_size):
            curr = min(batch_size, num_samples - i)
            z = torch.randn(curr, latent_dim).to(device)
            recon = model.decode(z)
            images.append(recon.cpu())
    return torch.cat(images, dim=0)


def main():
    start_all = time.time()
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    print(f"[INFO] Starting FID computation at {time.strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[INFO] Using device: {device}")

    parser = argparse.ArgumentParser(description="Compute FID for VAE-generated vs real samples using pytorch-fid")
    parser.add_argument('--config', type=str, required=True, help='Path to YAML config')
    parser.add_argument('--model-path', type=str, required=True, help='Path to VAE checkpoint (.pth)')
    parser.add_argument('--batch-size', type=int, default=32, help='Batch size for feature extraction')
    parser.add_argument('--num-samples', type=int, default=None,
                        help='Number of samples to use (both real and generated); defaults to full val set')
    parser.add_argument('--output', type=str, default='experiments/fid', help='Directory to save FID score')
    args = parser.parse_args()

    # Load config and model
    config = load_config(args.config)
    config['model']['checkpoint_path'] = args.model_path
    vae = VAE(
        in_channels=config['model']['in_channels'],
        latent_dim=config['model']['latent_dim']
    ).to(device)
    ckpt = torch.load(args.model_path, map_location=device)
    vae.load_state_dict(ckpt['model_state_dict'])

    # Initialize InceptionV3 for pool3 features
    block_idx = InceptionV3.BLOCK_INDEX_BY_DIM[2048]
    inception = InceptionV3([block_idx]).to(device)

    # Subset validation dataset and cache real activations
    _, val_files, _ = get_data()
    full_dataset = SingleCellDataset(val_files)
    total = len(full_dataset)
    num_samples = args.num_samples or total

    if args.num_samples is None:
        real_dataset = full_dataset
    else:
        # random but reproducible subset
        np.random.seed(0)
        indices = np.random.choice(total, num_samples, replace=False)
        real_dataset = Subset(full_dataset, indices)

    real_loader = DataLoader(real_dataset, batch_size=args.batch_size,
                             shuffle=False, drop_last=False)

    cache_dir = os.path.expanduser("~/.cache/bachelor_fid/")
    os.makedirs(cache_dir, exist_ok=True)
    cache_file = os.path.join(cache_dir, "real_activations.npy")

    if args.num_samples is None and os.path.exists(cache_file):
        print(f"[INFO] Loading cached real activations from {cache_file}")
        real_acts = np.load(cache_file)
    else:
        print("[STEP] Computing real activations...")
        t0 = time.time()
        real_acts = get_activations(real_loader, inception, device)
        print(f"[DONE] Real activations computed in {time.time() - t0:.1f}s")
        if args.num_samples is None:
            np.save(cache_file, real_acts)
            print(f"[INFO] Cached real activations to {cache_file}")

    print("[STEP] Generating images...")
    t1 = time.time()
    gen_images = generate_images(vae, num_samples, config['model']['latent_dim'], device, args.batch_size)
    print(f"[DONE] Generated {len(gen_images)} images in {time.time() - t1:.1f}s")
    gen_loader = DataLoader(TensorDataset(gen_images), batch_size=args.batch_size)

    print("[STEP] Computing generated activations...")
    t2 = time.time()
    gen_acts = get_activations(gen_loader, inception, device)
    print(f"[DONE] Generated activations computed in {time.time() - t2:.1f}s")

    # Compute statistics
    mu_real, sigma_real = calculate_activation_statistics(real_acts)
    mu_gen, sigma_gen = calculate_activation_statistics(gen_acts)

    print("[STEP] Calculating FID...")
    t3 = time.time()
    fid_value = calculate_frechet_distance(mu_real, sigma_real, mu_gen, sigma_gen)
    print(f"[DONE] FID calculated in {time.time() - t3:.1f}s")
    print(f"[ALL DONE] Total elapsed time: {time.time() - start_all:.1f}s")

    # Save and report
    os.makedirs(args.output, exist_ok=True)
    out_file = os.path.join(args.output, 'fid_score.txt')
    with open(out_file, 'w') as f:
        f.write(f'{fid_value:.6f}\n')

    print(f'[INFO] FID score: {fid_value:.6f}')
    print(f'[INFO] Saved FID score to {out_file}')

if __name__ == '__main__':
    main()
